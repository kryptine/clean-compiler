imports
{
from StdClass import class + (..)
from StdOverloaded import class < (..)
from StdInt import instance + Int, instance < Int
from StdList import ++, foldr, map
from StdOverloaded import class +++ (..)
from StdString import instance +++ {#Char}, instance toString Int
from StdFunc import o
import StdMisc
import Data.Void
import Data.Func
import Data.List

import Data.Graph
import Data.Maybe
import Text.PPrint
import Tonic.AbsSyn
import Tonic.Util
}

attr Expression Expressions
  syn ppAg          use {<$$>}  {empty}  :: {Doc}
  syn ppDebug       use {<$$>}  {empty}  :: {Doc}

  -- varC bv = ppAg inh bv
  --   appC app
  --     # args = dropAppContexts app inh
  --     = let ppargs xs = 'PP'.hcat $ intersperse ('PP'.text " ") $ map (pp inh) xs
  --       in  (case args of
  --              []     -> ppAg inh app.app_symb
  --              [x:xs] -> if (isInfix inh.inh_fun_defs inh.inh_icl_module inh.inh_dcl_modules app.app_symb)
  --                          (pp inh x 'PP'. <+> ppAg inh app.app_symb 'PP'. <+> ppargs xs)
  --                          (pp inh app.app_symb 'PP'. <+> ppargs args))
  --   basicC bv = ppAg inh bv
  --   defaultC = 'PP'.empty
  --   selectionC _ expr sels = 
  --   updateC _ _ _ = 'PP'.text "update"
  --   recordUpdateC _ _ _ = 'PP'.text "recordUpdate"
  --   tupleSelectC _ _ _ = 'PP'.text "tupleSelect"

sem Expression
  | Var
      lhs.ppDebug = text "<Var>" <+> ppAg @lhs.moduleEnv @bv
      lhs.ppAg    = ppAg @lhs.moduleEnv @bv

  | App
      lhs.ppDebug = let args    = @app|app_args // dropAppContexts @app @lhs.moduleEnv
                        argsPP  = hcat $ intersperse (text ", ") $ map (ppDebugExpression @lhs.moduleEnv) args
                    in  text "<App>" <+> ppAg @lhs.moduleEnv @app|app_symb <+> brackets argsPP

      lhs.ppAg    = let args       = @app|app_args // dropAppContexts @app @lhs.moduleEnv
                        ppargs xs  = hcat $ intersperse (text " ") $ map (ppAg @lhs.moduleEnv) xs
                    in  case args of
                          []     -> ppAg @lhs.moduleEnv @app|app_symb
                          [x:xs] -> if (isInfix @lhs.moduleEnv @app|app_symb)
                                      (ppAg @lhs.moduleEnv x <+> ppAg @lhs.moduleEnv @app|app_symb <+> ppargs xs)
                                      (ppAg @lhs.moduleEnv @app|app_symb <+> ppargs args)

  | Selection
      lhs.ppDebug = text "<Selection>" <+> @expr.ppDebug <-> char '.' <->
                    hcat (intersperse (char '.') $ map (ppAg @lhs.moduleEnv) @sels)

      lhs.ppAg    = @expr.ppAg <-> char '.' <->
                    hcat (intersperse (char '.') $ map (ppAg @lhs.moduleEnv) @sels)

  | Update
      lhs.ppDebug = text "<Update>"
      lhs.ppAg    = text "<Update>"

  | RecordUpdate
      lhs.ppDebug = text "<RecordUpdate>"
      lhs.ppAg    = text "<RecordUpdate>"

  | TupleSelect
      lhs.ppDebug = text "<TupleSelect>"
      lhs.ppAg    = text "<TupleSelect>"

  | BasicExpr
      lhs.ppDebug = text "<BasicValue>" <+> ppAg @lhs.moduleEnv @bv
      lhs.ppAg    = ppAg @lhs.moduleEnv @bv

{
mkPretty :: ModuleEnv -> (a -> String) | PPAG a
mkPretty menv = ppCompact o (ppAg menv)

ppCompact :: (Doc -> String)
ppCompact = display o renderCompact

ppExpression :: ModuleEnv Expression -> Doc
ppExpression menv expr = ppAg_Syn_Expression (wrap_Expression (sem_Expression expr) (mkPPInh menv))

ppDebugExpression :: ModuleEnv Expression -> Doc
ppDebugExpression menv expr = ppDebug_Syn_Expression (wrap_Expression (sem_Expression expr) (mkPPInh menv))

mkPPInh :: ModuleEnv -> Inh_Expression
mkPPInh me = Inh_Expression Nothing "" emptyGraph 0 me

mkTaskDot :: ModuleEnv String GGraph -> String
mkTaskDot menv funnm (GGraph g) = "subgraph cluster_" +++ funnm +++ " {\n label=\"" +++ funnm  +++ "\"  color=\"black\";\n" +++
  mkNodes +++ "\n" +++
  mkEdges +++ "\n}"
  where
  mkNodes = concatStrings (map (nodeToDot menv funnm g) (nodeIndices g))
  mkEdges = concatStrings (map edgeToDot (edgeIndices g))
  edgeToDot ei=:(l, r) = mkDotNodeLbl funnm l +++ " -> " +++ mkDotNodeLbl funnm r +++ mkDotArgs [mkDotAttrKV "label" edgeLbl] // TODO: Use different arrow for task assignment
    where edgeLbl = maybe "" (\e -> fromMaybe "" e.edge_pattern) $ getEdgeData ei g

mkDotAttrKV :: String String -> String
mkDotAttrKV k v = k +++ "=" +++ "\"" +++ v +++ "\""

mkDotArgs :: [String] -> String
mkDotArgs attrs = " [" +++ intercalateString ", " attrs +++ "];\n"

mkDotNodeLbl :: String Int -> String
mkDotNodeLbl funnm n = funnm +++ "_node_" +++ toString n

nodeToDot :: ModuleEnv String GinGraph Int -> String
nodeToDot menv funnm g currIdx =
  case currNode of
    GInit                 -> blackNode [shape "triangle", width ".25", height ".25", orientation "-90.0"]
    GStop                 -> blackNode [shape "box", width ".2", height ".2"]
    (GDecision _ expr)    -> whiteNode [shape "diamond", label expr]
    GMerge                -> blackNode [shape "diamond", width ".25", height ".25"]
    (GLet glt)            -> whiteNode [shape "box", label (intercalateString "\n" $ map (mkPretty menv) glt)] // TODO: Rounded corners
    GParallelSplit        -> whiteNode [shape "circle", label "Run in\nparallel"]
    (GParallelJoin jt)    -> whiteNode [shape "circle", label (mkJoinLbl jt)]
    (GTaskApp tid exprs)  -> whiteNode [shape "box", label tid] // TODO: complex contents with extra bar
    (GReturn expr)        -> whiteNode [shape "oval", label (mkPretty menv expr)]
    (GAssign usr)         -> let  idxStr = toString currIdx
                                  usrStr = "user" +++ idxStr
                             in   "subgraph cluster_user" +++ idxStr +++ "{ label=" +++ usr +++ "; labelloc=b; peripheries=0; " +++ usrStr +++ "}" +++
                                  usrStr +++ mkDotArgs [ mkDotAttrKV "shapefile" "\"stick.png\""
                                                       , mkDotAttrKV "peripheries" "0"
                                                       , style "invis" ]
    GStep                 -> whiteNode [shape "circle", label "Step"]
    GListComprehension    -> whiteNode [shape "box", style "rounded", label "for each in (listcomprehension)"]
  where
  currNode         = getNodeData` currIdx g
  whiteNode attrs  = mkDotNode [fontcolor "black", fillcolor "white", style "filled", label "" : attrs]
  blackNode attrs  = mkDotNode [fontcolor "white", fillcolor "black", style "filled", label "" : attrs]
  mkDotNode attrs  = mkDotNodeLbl funnm currIdx +++ mkDotArgs attrs
  shape v          = mkDotAttrKV "shape" v
  label v          = mkDotAttrKV "label" v
  color v          = mkDotAttrKV "color" v
  fillcolor v      = mkDotAttrKV "fillcolor" v
  fontcolor v      = mkDotAttrKV "fontcolor" v
  width v          = mkDotAttrKV "width" v
  height v         = mkDotAttrKV "height" v
  style v          = mkDotAttrKV "style" v
  orientation v    = mkDotAttrKV "orientation" v
  mkJoinLbl DisFirstBin   = "First\nfinished\ntask"
  mkJoinLbl DisFirstList  = "First\nfinished\ntask"
  mkJoinLbl DisLeft       = "Left\nresult"
  mkJoinLbl DisRight      = "Right\nresult"
  mkJoinLbl ConAll        = "All\nresults"
  mkJoinLbl ConPair       = "Pair\nof results"

getNodeData` :: Int GinGraph -> GNode
getNodeData` n g = fromMaybe err (getNodeData n g)
  where err = abort ("No data for node " +++ toString n)

class PPAG a where
  ppAg :: ModuleEnv a -> Doc

instance PPAG Expression where
  ppAg menv expr = ppExpression menv expr
  /*ppAg menv expr = ppDebugExpression menv expr*/

instance PPAG Ident where
  ppAg _ i = text i.id_name

instance PPAG BoundVar where
  ppAg menv bv = ppAg menv bv.var_ident

instance PPAG FreeVar where
  ppAg menv fv = ppAg menv fv.fv_ident

instance PPAG SymbIdent where
  ppAg menv si = ppAg menv si.symb_ident

instance PPAG BasicValue where
  ppAg _ (BVI str)  = text str
  ppAg _ (BVInt i)  = int i
  ppAg _ (BVC str)  = text str
  ppAg _ (BVB b)    = bool b
  ppAg _ (BVR str)  = text str
  ppAg _ (BVS str)  = text str

instance PPAG DefinedSymbol where
  ppAg menv ds = ppAg menv ds.ds_ident

instance PPAG Selection where
  ppAg menv (RecordSelection gds _)     = ppAg menv gds.glob_object
  ppAg _ (ArraySelection _ _ _)         = text "TODO: ArraySelection"
  ppAg _ (DictionarySelection _ _ _ _)  = text "TODO: DictionarySelection"

instance PPAG GExpression where
  ppAg _ GUndefinedExpression      = text "undef"
  ppAg _ (GGraphExpression graph)  = text "TODO: render a subgraph (and don't PP one)"
  ppAg _ (GListExpression ges)     = text "TODO: render a list expression (and don't PP one)"
  //ppAg _ (GListComprehensionExpression glc)  = text "TODO: render a list comprehension expression (and don't PP one)"
  ppAg _ (GCleanExpression ce)     = text ce

instance PPAG GLet where
  ppAg menv gl = vcat (map (ppAg menv) gl.glet_binds)

instance PPAG GLetBind where
  ppAg menv lb = text lb.glb_dst <+> equals <+> ppAg menv lb.glb_src

}
