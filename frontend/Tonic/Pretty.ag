imports
{
from StdClass import class + (..)
from StdOverloaded import class < (..)
from StdInt import instance + Int, instance < Int
from StdList import ++, foldr, map
from StdOverloaded import class +++ (..)
from StdString import instance +++ {#Char}, instance toString Int
from StdFunc import o
import StdMisc
import Data.Void
import Data.Func
import Data.List

import Data.Graph
import Data.Maybe
import Text.PPrint
import Tonic.AbsSyn
import Tonic.Util
}

attr Expression Expressions Ident BoundVar FreeVar SymbIdent BasicValue
  DefinedSymbol Selection Selections GExpression GLet GLetBind GLetBinds
  GlobalDefinedSymbol App SymbolType
  syn ppAg          use {<$$>}  {empty}  :: {Doc}
  syn ppAgs         use {++}    {[]}     :: {[Doc]}
  syn ppDebug       use {<$$>}  {empty}  :: {Doc}
  syn ppDebugs      use {++}    {[]}     :: {[Doc]}

attr SymbIdent
  syn isInfix    :: {Bool}

sem SymbIdent
  | SymbIdent lhs.isInfix    = let mfd  = reifyFunDef @lhs.moduleEnv @symb_ident.copy
                                   mft  = reifyFunType @lhs.moduleEnv @symb_ident.copy
                                   isInfix` (Prio _ _) = True
                                   isInfix` _          = False
                               in  case mfd of
                                     Just fd  -> isInfix` fd.gfd_priority
                                     Nothing  ->
                                       case mft of
                                         Just ft  -> isInfix` ft.ft_priority
                                         _        -> abort ("Failed to determine fixity for " +++ ppCompact @symb_ident.ppAg)

  -- varC bv = ppAg inh bv
  --   appC app
  --     # args = dropAppContexts app inh
  --     = let ppargs xs = 'PP'.hcat $ intersperse ('PP'.text " ") $ map (pp inh) xs
  --       in  (case args of
  --              []     -> ppAg inh app.app_symb
  --              [x:xs] -> if (isInfix inh.inh_fun_defs inh.inh_icl_module inh.inh_dcl_modules app.app_symb)
  --                          (pp inh x 'PP'. <+> ppAg inh app.app_symb 'PP'. <+> ppargs xs)
  --                          (pp inh app.app_symb 'PP'. <+> ppargs args))
  --   basicC bv = ppAg inh bv
  --   defaultC = 'PP'.empty
  --   selectionC _ expr sels = 
  --   updateC _ _ _ = 'PP'.text "update"
  --   recordUpdateC _ _ _ = 'PP'.text "recordUpdate"
  --   tupleSelectC _ _ _ = 'PP'.text "tupleSelect"

sem App
  | App
      lhs.ppDebug = let argsPP = hcat $ intersperse (text ", ") @app_args.ppAgs
                    in  text "<App>" <+> @app_symb.ppAg <+> brackets argsPP

      lhs.ppAg    = let appc      = @copy
                    in  case appc.app_args of
                          []     -> @app_symb.ppAg
                          [x:xs] -> if @app_symb.isInfix
                                      (ppExpression @lhs.moduleEnv x <+> @app_symb.ppAg <+> hcat (intersperse (text " ") (map (ppExpression @lhs.moduleEnv) xs)))
                                      (@app_symb.ppAg <+> hcat (intersperse (text " ") @app_args.ppAgs))

sem Expression
  | Var
      lhs.ppDebug = text "<Var>" <+> @bv.ppDebug
      lhs.ppAg    = @bv.ppAg

  | App lhs.ppDebug = @app.ppDebug
        lhs.ppAg    = @app.ppAg

  | Selection
      lhs.ppDebug = text "<Selection>" <+> @expr.ppDebug <-> @loc.recsel

      lhs.ppAg    = @expr.ppAg <-> @loc.recsel
      loc.recsel  = char '.' <-> hcat (intersperse (char '.') $ @sels.ppAgs)

  | Update
      lhs.ppDebug = text "<Update>"
      lhs.ppAg    = text "<Update>"

  | RecordUpdate
      lhs.ppDebug = text "<RecordUpdate>"
      lhs.ppAg    = text "<RecordUpdate>"

  | TupleSelect
      lhs.ppDebug = text "<TupleSelect>"
      lhs.ppAg    = text "<TupleSelect>"

  | BasicExpr
      lhs.ppDebug = text "<BasicValue>" <+> @bv.ppDebug
      lhs.ppAg    = @bv.ppAg

sem Ident
  | Ident lhs.ppDebug = text @id_name
          lhs.ppAg    = text @id_name

sem BoundVar
  | BoundVar lhs.ppDebug = @var_ident.ppDebug
             lhs.ppAg    = @var_ident.ppAg

sem FreeVar
  | FreeVar lhs.ppDebug = @fv_ident.ppDebug
            lhs.ppAg    = @fv_ident.ppAg

sem SymbIdent
  | SymbIdent lhs.ppDebug = @symb_ident.ppDebug
              lhs.ppAg    = @symb_ident.ppAg

sem BasicValue
  | BVI lhs.ppDebug = text @str
        lhs.ppAg    = text @str
  | BVInt lhs.ppDebug = int @i
          lhs.ppAg    = int @i
  | BVC lhs.ppDebug = text @str
        lhs.ppAg    = text @str
  | BVB lhs.ppDebug = bool @b
        lhs.ppAg    = bool @b
  | BVR lhs.ppDebug = text @str
        lhs.ppAg    = text @str
  | BVS lhs.ppDebug = text @str
        lhs.ppAg    = text @str

sem DefinedSymbol
  | DefinedSymbol lhs.ppDebug = @ds_ident.ppDebug
                  lhs.ppAg    = @ds_ident.ppAg

sem Selection
  | RecordSelection     lhs.ppDebug = @gds.ppDebug
                        lhs.ppAg    = @gds.ppAg
  | ArraySelection      lhs.ppDebug = text "TODO: ArraySelection"
                        lhs.ppAg    = text "TODO: ArraySelection"
  | DictionarySelection lhs.ppDebug = text "TODO: DictionarySelection"
                        lhs.ppAg    = text "TODO: DictionarySelection"

sem GExpression
  | GUndefinedExpression  lhs.ppDebug = text "undef"
                          lhs.ppAg    = text "undef"
  | GGraphExpression      lhs.ppDebug = text "TODO: render a subgraph (and don't PP one)"
                          lhs.ppAg    = text "TODO: render a subgraph (and don't PP one)"
  | GListExpression       lhs.ppDebug = text "TODO: render a list expression (and don't PP one)"
                          lhs.ppAg    = text "TODO: render a list expression (and don't PP one)"
  | GCleanExpression      lhs.ppDebug = text @gcexpr
                          lhs.ppAg    = text @gcexpr

sem GLet
  | GLet lhs.ppDebug = vcat @glet_binds.ppDebugs
         lhs.ppAg    = vcat @glet_binds.ppAgs

sem GLetBind
  | GLetBind lhs.ppDebug = text @glb_dst <+> equals <+> @glb_src.ppDebug
             lhs.ppAg    = text @glb_dst <+> equals <+> @glb_src.ppAg

{
mkPrettyExpr :: ModuleEnv Expression -> String
mkPrettyExpr menv expr = ppCompact (ppExpression menv expr)

ppCompact :: (Doc -> String)
ppCompact = display o renderCompact

ppExpression :: ModuleEnv Expression -> Doc
ppExpression menv expr = ppAg_Syn_Expression (wrap_Expression (sem_Expression expr) (mkPPInhExpression menv))

ppGExpression :: ModuleEnv GExpression -> Doc
ppGExpression menv expr = ppAg_Syn_GExpression (wrap_GExpression (sem_GExpression expr) (mkPPInhGExpression menv))

ppGLetBind :: ModuleEnv GLetBind -> Doc
ppGLetBind menv expr = ppAg_Syn_GLetBind (wrap_GLetBind (sem_GLetBind expr) (mkPPInhGLetBind menv))

ppDebugExpression :: ModuleEnv Expression -> Doc
ppDebugExpression menv expr = ppDebug_Syn_Expression (wrap_Expression (sem_Expression expr) (mkPPInhExpression menv))

ppFreeVar :: ModuleEnv FreeVar -> Doc
ppFreeVar menv fv = ppAg_Syn_FreeVar (wrap_FreeVar (sem_FreeVar fv) (mkPPInhFreeVar menv))

mkPPInhExpression :: ModuleEnv -> Inh_Expression
mkPPInhExpression me = Inh_Expression Nothing "" emptyGraph 0 me

mkPPInhGExpression :: ModuleEnv -> Inh_GExpression
mkPPInhGExpression me = Inh_GExpression Nothing "" emptyGraph 0 me

mkPPInhGLetBind :: ModuleEnv -> Inh_GLetBind
mkPPInhGLetBind me = Inh_GLetBind Nothing "" emptyGraph 0 me

mkPPInhFreeVar :: ModuleEnv -> Inh_FreeVar
mkPPInhFreeVar me = Inh_FreeVar Nothing "" emptyGraph 0 me


mkTaskDot :: ModuleEnv String GGraph -> String
mkTaskDot menv funnm (GGraph g) = "subgraph cluster_" +++ funnm +++ " {\n label=\"" +++ funnm  +++ "\"  color=\"black\";\n" +++
  mkNodes +++ "\n" +++
  mkEdges +++ "\n}"
  where
  mkNodes = concatStrings (map (nodeToDot menv funnm g) (nodeIndices g))
  mkEdges = concatStrings (map edgeToDot (edgeIndices g))
  edgeToDot ei=:(l, r) = mkDotNodeLbl funnm l +++ " -> " +++ mkDotNodeLbl funnm r +++ mkDotArgs [mkDotAttrKV "label" edgeLbl] // TODO: Use different arrow for task assignment
    where edgeLbl = maybe "" (\e -> fromMaybe "" e.edge_pattern) $ getEdgeData ei g

mkDotAttrKV :: String String -> String
mkDotAttrKV k v = k +++ "=" +++ "\"" +++ v +++ "\""

mkDotArgs :: [String] -> String
mkDotArgs attrs = " [" +++ intercalateString ", " attrs +++ "];\n"

mkDotNodeLbl :: String Int -> String
mkDotNodeLbl funnm n = funnm +++ "_node_" +++ toString n

nodeToDot :: ModuleEnv String GinGraph Int -> String
nodeToDot menv funnm g currIdx =
  case currNode of
    GInit                 -> blackNode [shape "triangle", width ".25", height ".25", orientation "-90.0"]
    GStop                 -> blackNode [shape "box", width ".2", height ".2"]
    (GDecision _ expr)    -> whiteNode [shape "diamond", label expr]
    GMerge                -> blackNode [shape "diamond", width ".25", height ".25"]
    (GLet glt)            -> whiteNode [shape "box", label (intercalateString "\n" $ map (ppCompact o ppGLetBind menv) glt)] // TODO: Rounded corners
    GParallelSplit        -> whiteNode [shape "circle", label "Run in\nparallel"]
    (GParallelJoin jt)    -> whiteNode [shape "circle", label (mkJoinLbl jt)]
    (GTaskApp tid exprs)  -> whiteNode [shape "box", label tid] // TODO: complex contents with extra bar
    (GReturn expr)        -> whiteNode [shape "oval", label (ppCompact $ ppGExpression menv expr)]
    (GAssign usr)         -> let  idxStr = toString currIdx
                                  usrStr = "user" +++ idxStr
                             in   "subgraph cluster_user" +++ idxStr +++ "{ label=" +++ usr +++ "; labelloc=b; peripheries=0; " +++ usrStr +++ "}" +++
                                  usrStr +++ mkDotArgs [ mkDotAttrKV "shapefile" "\"stick.png\""
                                                       , mkDotAttrKV "peripheries" "0"
                                                       , style "invis" ]
    GStep                 -> whiteNode [shape "circle", label "Step"]
    GListComprehension    -> whiteNode [shape "box", style "rounded", label "for each in (listcomprehension)"]
  where
  currNode         = getNodeData` currIdx g
  whiteNode attrs  = mkDotNode [fontcolor "black", fillcolor "white", style "filled", label "" : attrs]
  blackNode attrs  = mkDotNode [fontcolor "white", fillcolor "black", style "filled", label "" : attrs]
  mkDotNode attrs  = mkDotNodeLbl funnm currIdx +++ mkDotArgs attrs
  shape v          = mkDotAttrKV "shape" v
  label v          = mkDotAttrKV "label" v
  color v          = mkDotAttrKV "color" v
  fillcolor v      = mkDotAttrKV "fillcolor" v
  fontcolor v      = mkDotAttrKV "fontcolor" v
  width v          = mkDotAttrKV "width" v
  height v         = mkDotAttrKV "height" v
  style v          = mkDotAttrKV "style" v
  orientation v    = mkDotAttrKV "orientation" v
  mkJoinLbl DisFirstBin   = "First\nfinished\ntask"
  mkJoinLbl DisFirstList  = "First\nfinished\ntask"
  mkJoinLbl DisLeft       = "Left\nresult"
  mkJoinLbl DisRight      = "Right\nresult"
  mkJoinLbl ConAll        = "All\nresults"
  mkJoinLbl ConPair       = "Pair\nof results"

getNodeData` :: Int GinGraph -> GNode
getNodeData` n g = fromMaybe err (getNodeData n g)
  where err = abort ("No data for node " +++ toString n)
}
