imports
{
from StdClass import class + (..)
from StdOverloaded import class < (..)
from StdInt import instance + Int, instance < Int
from StdList import ++, foldr, map
from StdOverloaded import class +++ (..)
from StdString import instance +++ {#Char}, instance toString Int, instance == {#Char}
from StdFunc import o
from StdBool import ||
import StdMisc
import Data.Void
import Data.Func
import Data.List

import Data.Graph
import Data.Maybe
import Text.PPrint
import Tonic.AbsSyn
import Tonic.Util
from syntax import :: Optional (..), :: FunDef {..}, :: FunInfo, :: FunKind,
  :: FunctionBody {..}, :: TransformedBody {..}, :: CheckedBody, :: ParsedBody,
  :: AType {..}, :: TypeAttribute, :: Type {..}, :: TypeKind, :: TempVarId,
  :: ATypeVar, :: BasicType, :: ConsVariable, :: TypeSymbIdent {..},
  :: TypeSymbProperties
}

attr Expression Expressions Ident BoundVar FreeVar FreeVars SymbIdent
  BasicValue DefinedSymbol Selection Selections GExpression GLet GLetBind
  GLetBinds GlobalDefinedSymbol App SymbolType GFunDef
  inh mergeId                            :: {Int}
  inh currTaskName                       :: {String}
  inh caseExpr                           :: {Maybe Expression}
  chn graph                              :: {GinGraph}
  syn hasRecs       use {||}  {False}    :: {Bool}
  syn recNode       use {||}  {False}    :: {Bool}
  syn mEntryId      use {<>}  {Nothing}  :: {Maybe Int}
  syn mExitId       use {<>}  {Nothing}  :: {Maybe Int}

attr App Ident SymbIdent
  syn reifyFunType    :: {Maybe FunType}
  syn reifySymbolType :: {Maybe SymbolType}
  syn reifyFunDef     :: {Maybe GFunDef}

attr App SymbIdent Ident SymbolType
  syn isTask      :: {Bool}

attr SymbIdent
  syn isCurrTask :: {Bool}

attr SymbIdent Ident
  syn ident :: {String}

sem SymbolType
  | SymbolType
      lhs.isTask =  case @st_result|at_type of
                      TA   tsi _     -> symTyIsTask` tsi
                      TAS  tsi _  _  -> symTyIsTask` tsi
                      _              -> False
                    where symTyIsTask` tsi = tsi.type_ident.id_name == "Task"

sem Ident
  | Ident
      lhs.ident  = @id_name
      lhs.isTask = @identSymbolType.isTask

      inst.identSymbolType :: SymbolType
      inst.identSymbolType = fromMaybe (abort $ "inst.identSymbolType: " +++ @id_name)
                             @loc.reifySymbolType

      lhs.reifyFunType    = reifyFunType @lhs.moduleEnv @copy
      lhs.reifySymbolType = @loc.reifySymbolType
      loc.reifySymbolType = reifySymbolType @lhs.moduleEnv @copy
      lhs.reifyFunDef     = reifyFunDef @lhs.moduleEnv @copy


sem App
  | App
      lhs.reifyFunDef = @app_symb.reifyFunDef
      lhs.reifySymbolType = @app_symb.reifySymbolType

      loc.noContextArgs = if @loc.isListApp
                            @app_args.copy
                            (let funTy  = fromMaybe (abort err) @app_symb.reifySymbolType
                                 err    = "noContextArgs : failed to find symbol type for " +++ @app_symb.ident
                             in  dropContexts funTy @app_args.copy)

      loc.isListApp = @app_symb.ident == "_Cons" || @app_symb.ident == "_Nil"
      lhs.isTask    = @loc.isTask
      loc.isTask    = @app_symb.isTask

sem SymbIdent
  | SymbIdent
     lhs.reifyFunDef  = reifyFunDef @lhs.moduleEnv @symb_ident.copy
     lhs.reifySymbolType  = @symb_ident.reifySymbolType

     loc.ident        = @symb_ident.ident
     lhs.ident        = @loc.ident
     lhs.isCurrTask   = @loc.ident == @lhs.currTaskName
     lhs.isTask       = @symb_ident.isTask

attr GFunDef
  syn funArgs :: {[FreeVar]}
  syn funRhs  :: Expression

sem GFunDef
  | GFunDef
      lhs.funArgs = @gfd_args.copy
      lhs.funRhs  = @gfd_rhs.copy

      lhs.mEntryId = @gfd_rhs.mEntryId
      lhs.mExitId  = @gfd_rhs.mExitId

      gfd_rhs.graph = @lhs.graph
      lhs.graph     = @gfd_rhs.graph

sem App
  | App
      lhs.graph = if (symbIdentIsTask @lhs.moduleEnv @app_symb.copy)
                    @loc.taskGraph
                    @lhs.graph
      lhs.mEntryId = @loc.taskEntryId
      lhs.mExitId  = @loc.taskExitId

      loc.(taskGraph, taskEntryId, taskExitId) = case @app_symb.ident of // TODO `parallel`
                                                   ">>="       -> (@loc.bindGraph,                    Nothing,                            Nothing)
                                                   "return"    -> (@loc.returnGraph,                  Just @loc.returnId,                 Just @loc.returnId)
                                                   ">>|"       -> (@loc.binAppGraph Nothing,          Nothing,                            Nothing)
                                                   "@:"        -> (@loc.assignGraph,                  Just @loc.assignId,                 Just @loc.assignId)
                                                   ">>*"       -> (@loc.stepGraph,                    @loc.stepEntryId,                   @loc.stepExitId)
                                                   "-||-"      -> (@loc.parBinAppGraph DisFirstBin,   Nothing,                            Nothing)
                                                   "||-"       -> (@loc.parBinAppGraph DisRight,      Nothing,                            Nothing)
                                                   "-||"       -> (@loc.parBinAppGraph DisLeft,       Nothing,                            Nothing)
                                                   "-&&-"      -> (@loc.parBinAppGraph ConPair,       Nothing,                            Nothing)
                                                   "anyTask"   -> (@loc.parListAppGraph DisFirstList, @loc.parListAppEntryId DisFirstBin, @loc.parListAppExitId DisFirstBin)
                                                   "allTasks"  -> (@loc.parListAppGraph ConAll,       @loc.parListAppEntryId DisFirstBin, @loc.parListAppExitId DisFirstBin)
                                                   _           -> (@loc.taskAppGraph,                 @loc.taskAppId,                     @loc.taskAppId)

      loc.(appArg1, mAppArg2) = case @loc.noContextArgs of
                                  [e1:e2:_]  -> (e1, Just e2)
                                  [e1:_]     -> (e1, Nothing)
                                  _          -> abort ("App has no args: " +++ @app_symb.ident)

      inst.appArg1Expr :: Expression
      inst.appArg1Expr = @loc.appArg1

      inst.appArg2Expr :: Expression
      inst.appArg2Expr = fromMaybe (abort "No second argument to app") @loc.mAppArg2

      inst.bindRhsAppI :: App
      inst.bindRhsAppI = case @loc.mAppArg2 of
                           Just (App a)  -> a
                           _             -> abort "Invalid bind"

      loc.bindRhsSymbolType = fromMaybe (abort "mkGraphAlg #2: failed to find symbol type")
                              @bindRhsAppI.reifySymbolType

      inst.bindRhsFunDef :: GFunDef
      inst.bindRhsFunDef = fromMaybe (abort "mkGraphAlg #1: failed to find function definition")
                           @bindRhsAppI.reifyFunDef

      inst.bindRhsSymbolTypeI :: SymbolType
      inst.bindRhsSymbolTypeI = @loc.bindRhsSymbolType

      bindRhsFunDef.graph = @appArg1Expr.graph

      loc.bindGraph = case ( @appArg1Expr.mEntryId, @appArg1Expr.mExitId
                           , @bindRhsFunDef.mEntryId, @bindRhsFunDef.mExitId) of
                        (Just _, Just lx, Just rn, Just _)
                           # patid = withHead freeVarName (abort "Invalid bind")
                                   $ [x \\ x <- dropContexts @loc.bindRhsSymbolType @bindRhsFunDef.funArgs | x.fv_def_level == -1]
                           = addEdge (mkEdge patid) (lx, rn) @lhs.graph
                        (_, lid, rid, _)        = edgeErr @lhs.moduleEnv "bind edge" lid @loc.appArg1 rid @bindRhsFunDef.funRhs

      loc.(returnId, returnGraph) = // TODO No error: eta-reduction
                                    let node   = GReturn $ withHead f (abort "Invalid return") @loc.noContextArgs
                                        // In case of a function application, we want to inspect the type of the
                                        // function. If it is a task or a list, treat it differently than any
                                        // other type.
                                        f _ = GCleanExpression "(return)"
                                    in  addNode node @lhs.graph

      inst.binAppArg2Expr :: Expression
      inst.binAppArg2Expr = fromMaybe (abort "No second argument to app") @loc.mAppArg2

      binAppArg2Expr.graph = @appArg1Expr.graph

      loc.binAppGraph = \mPat -> case ( @appArg1Expr.mEntryId, @appArg1Expr.mExitId
                                      , @binAppArg2Expr.mEntryId, @binAppArg2Expr.mExitId) of
                                   (Just _, Just lx, Just rn, Just _)  -> addEdge (maybe emptyEdge mkEdge mPat) (lx, rn) @appArg1Expr.graph
                                   _                                   -> abort "binAppGraph"

      loc.(assignId, assignGraph) = let (n, g) = addNode (GAssign "Assign node") @lhs.graph
                                    in  case @appArg1Expr.mEntryId of
                                          Just r -> (n, addEmptyEdge (n, r) g)
                                          _      -> abort "Illegal task assignment"

      loc.stepGraph = abort "Step not implemented yet"
      loc.stepEntryId = Nothing
      loc.stepExitId = Nothing

      inst.parBinAppArg2Expr :: Expression
      inst.parBinAppArg2Expr = fromMaybe (abort "No second argument to app") @loc.mAppArg2

      parBinAppArg2Expr.graph = @appArg1Expr.graph

      loc.parBinAppGraph = \join -> let (sid, g1) = addNode GParallelSplit @parBinAppArg2Expr.graph
                                        (jid, g2) = addNode (GParallelJoin join) g1
                                    in  case ( @appArg1Expr.mEntryId, @appArg1Expr.mExitId
                                             , @parBinAppArg2Expr.mEntryId, @parBinAppArg2Expr.mExitId) of
                                          (_, Just l, Just r, _)
                                            # g = addEmptyEdge (sid, l) g2
                                            # g = addEmptyEdge (sid, r) g
                                            # g = addEmptyEdge (l, jid) g
                                            = addEmptyEdge (r, jid) g
                                          (_, lid, rid, _) = abort "Illegal parBinApp"

      loc.parListAppGraph   = \join -> undef
      loc.parListAppEntryId = \join -> undef
      loc.parListAppExitId  = \join -> undef

      loc.(taskAppId, taskAppGraph) = if @app_symb.isCurrTask
                                        (Nothing, @lhs.graph)
                                        (let appArgs = map (GCleanExpression o ppCompact) @app_args.ppAgs  // TODO: When do we pprint a Clean expr? And when do we generate a subgraph?
                                             (n, g)  = addNode (GTaskApp @app_symb.ident appArgs) @lhs.graph
                                         in (Just n, g))

sem Expression
  | App
      lhs.graph = @app.graph

  | Let
      lhs.graph = @glet.graph

      inst.glet :: GLet
      inst.glet = mkGLet @lhs.moduleEnv @let_

sem GLet
  | GLet
      lhs.graph = case @loc.mCaseVarExpr of
                    Just e  -> @glet_expr.graph
                    _       -> let (lid, g)  = addNode (GLet @glet_binds.copy) @glet_expr.graph
                                   // TODO: Represent the bindings in any way possible, not just PP
                                   err       = abort "Failed to add let edge; no synthesized ID from let body"
                               in maybe err (\n -> addEmptyEdge (lid, n) g) @loc.connId

      loc.mCaseVarExpr = @glet_binds.mCaseVarExpr

      glet_expr.caseExpr = @loc.mCaseVarExpr

      lhs.recNode = False

      loc.connId = if @glet_expr.recNode (Just @lhs.mergeId) @glet_expr.mEntryId

attr GLetBind GLetBinds
  syn mCaseVarExpr :: {Maybe Expression}

sem GLetBinds
  | Cons  lhs.mCaseVarExpr = @hd.mCaseVarExpr <> @tl.mCaseVarExpr
  | Nil   lhs.mCaseVarExpr = Nothing

sem GLetBind
  | GLetBind lhs.mCaseVarExpr = if (@glb_dst == "_case_var") (Just @glb_src.copy) Nothing

{

(<>) infixr 5 :: (Maybe a) (Maybe a) -> Maybe a
(<>) Nothing  ma  = ma
(<>) ma       _   = ma

mkGinGraph :: Int String GinGraph ModuleEnv Expression -> GinGraph
mkGinGraph mid ctn gg menv expr =
  graph_Syn_Expression (wrap_Expression (sem_Expression expr)
                       (Inh_Expression Nothing ctn gg mid menv))

listExprToList :: Expression -> [Expression]
listExprToList (App app) =
  case app.app_symb.symb_ident.id_name of
    "_Cons" ->
      case app.app_args of
        [head:tail:_] -> [head : listExprToList tail]
        _             -> abort "listExprToList should not happen"
    "_Nil"  -> []
    _       -> abort "listExprToList: App is not a list"
listExprToList _ = []

nodeErr :: ModuleEnv (Maybe Int) Expression -> String
nodeErr menv mn expr = ppCompact (ppExpression menv expr) +++ "\n" +++
  maybe "for which its ID is unknown" (\n -> "with node ID " +++ toString n) mn

edgeErr :: ModuleEnv String (Maybe Int) Expression (Maybe Int) Expression -> a
edgeErr menv errmsg lid lexpr rid rexpr = abort ("Cannot create " +++ errmsg
  +++ " between left expression\n\t" +++ nodeErr menv lid lexpr
  +++ " and right expression\n\t" +++ nodeErr menv rid rexpr +++ "\n")

addEmptyEdge :: (Int, Int) GinGraph -> GinGraph
addEmptyEdge e g = addEdge emptyEdge e g

addNode` :: GNode GinGraph -> SynExpression
addNode` node graph
  # (n, g) = addNode node graph
  = mkSynExpr (Just n) g

// TODO: We need to split this up: one part of this should generate the graph
// for the FunDef and the other part should generate the init and stop nodes.
// Yet another part should just get the right-hand side Expression of a FunDef
// so we can just cata it.
funToGraph :: FunDef {#FunDef} IclModule {#DclModule} -> Optional GGraph
funToGraph {fun_ident=fun_ident, fun_body = TransformedBody tb} fun_defs icl_module dcl_modules
  = Yes $ GGraph mkBody
  where
  mkBody
    # (mergeId, g)  = addNode GMerge emptyGraph
    # inh           = mkInhExpr (mkModuleEnv fun_defs icl_module dcl_modules) g mergeId fun_ident.id_name Nothing
    # gram          = wrapExpr tb.tb_rhs inh
    # g             = graph_Syn_Expression gram
    # (initId, g)   = addNode GInit g
    # g             = if (hasRecs_Syn_Expression gram)
                        (mkRec (mEntryId_Syn_Expression gram) initId mergeId g)
                        (mkNonrec (mEntryId_Syn_Expression gram) initId mergeId g)
    = addStopEdges g

  addStopEdges g
    # leafs        = leafNodes g
    # (stopId, g)  = addNode GStop g
    = foldr (\nid g_ -> addEmptyEdge (nid, stopId) g_) g leafs

  mkRec mfirstId initId mergeId g
    # g = addEmptyEdge (initId, mergeId) g
    = maybe g (\firstId -> addEmptyEdge (mergeId, firstId) g) mfirstId

  mkNonrec mfirstId initId mergeId g
    # g = removeNode mergeId g
    = maybe g (\firstId -> addEmptyEdge (initId, firstId) g) mfirstId

  mkInhExpr menv g mid nm ce = Inh_Expression ce nm g mid menv

  wrapExpr expr inh = wrap_Expression (sem_Expression expr) inh

funToGraph _ _ _ _ = No

instance toString GNode where
  toString GInit = "GInit"
  toString GStop = "GStop"
  toString (GDecision _ _) = "GDecision"
  toString GMerge = "GMerge"
  toString (GLet _) = "GLet"
  toString GParallelSplit = "GParallelSplit"
  toString (GParallelJoin _) = "GParallelJoin"
  toString (GTaskApp _ _) = "GTaskApp"
  toString (GReturn _) = "GReturn"
  toString (GAssign _) = "GAssign"
  toString GStep = "GStep"
  toString GListComprehension = "GListComprehension"

/*
Task assignment drawing: Needs a stick.png with a stick figure (can be PDF?)
digraph G {
   rankdir=LR;

    subgraph clusterUser {label="User"; labelloc="b"; peripheries=0; user};
    user [shapefile="stick.png", peripheries=0, style=invis];

    login [label="Log In", shape=ellipse];

    user->login [arrowhead=none];
}
*/
}
