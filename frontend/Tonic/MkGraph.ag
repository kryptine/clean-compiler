imports
{
from StdClass import class + (..)
from StdOverloaded import class < (..)
from StdInt import instance + Int, instance < Int
from StdList import ++, foldr, map
from StdOverloaded import class +++ (..)
from StdString import instance +++ {#Char}, instance toString Int, instance == {#Char}
from StdFunc import o
from StdBool import ||
import StdMisc
import Data.Void
import Data.Func
from Data.Functor import class Functor (..)
import Data.List

import Data.Graph
import Data.Maybe
import Text.PPrint
import Tonic.AbsSyn
import Tonic.Util
import StdDebug
import _SystemArray

from syntax import :: Optional (..), :: FunDef {..}, :: DclModule {..},
  :: IclModule {..}, :: ForeignExport, :: ImportedObject, :: QualifiedDeclaration,
  :: Declaration, :: IclFunctionIndices, :: ModuleIdent,
  :: FunInfo, :: FunKind, :: FunctionBody {..}, :: TransformedBody {..},
  :: CheckedBody, :: ParsedBody, :: AType {..}, :: TypeAttribute, :: Type {..},
  :: TypeKind, :: TempVarId, :: ATypeVar, :: BasicType, :: ConsVariable,
  :: TypeSymbIdent {..}, :: TypeSymbProperties, :: NumberSet, :: ModuleKind,
  :: Declarations, :: DictionaryInfo, :: CommonDefs, :: IndexRange
}

attr Expression Expressions Ident BoundVar FreeVar FreeVars SymbIdent
  BasicValue DefinedSymbol Selection Selections GExpression GLet GLetBind
  GLetBinds GlobalDefinedSymbol App SymbolType GFunDef FunType MaybeExpression
  syn hasRecs       use {||}  {False}    :: {Bool}
  syn recNode       use {||}  {False}    :: {Bool}
  syn mEntryId      use {<>}  {Nothing}  :: {Maybe Int}
  syn mExitId       use {<>}  {Nothing}  :: {Maybe Int}

attr SymbIdent Ident
  syn isCurrTask :: {Bool}

attr SymbIdent Ident
  syn ident    :: {String}

attr App Expressions
  syn firstArg                                :: MaybeExpression
  syn secondArg                               :: MaybeExpression
  syn firstArgIdent                           :: {String}
  syn secondArgIdent                          :: {String}
  syn firstArgGraph                           :: {GinGraph}
  syn secondArgGraph                          :: {GinGraph}
  syn firstArgMEntryId   use {<>}  {Nothing}  :: {Maybe Int}
  syn secondArgMEntryId  use {<>}  {Nothing}  :: {Maybe Int}
  syn firstArgMExitId    use {<>}  {Nothing}  :: {Maybe Int}
  syn secondArgMExitId   use {<>}  {Nothing}  :: {Maybe Int}
  syn firstArgHasRecs    use {||}  {False}    :: {Bool}
  syn secondArgHasRecs   use {||}  {False}    :: {Bool}
  syn firstArgRecNode    use {||}  {False}    :: {Bool}
  syn secondArgRecNode   use {||}  {False}    :: {Bool}

attr Expressions
  inh numContexts :: {Int}

sem Expressions
  | Cons loc.hasContexts = @lhs.numContexts > 0

         lhs.firstArg    = if @hasContexts @tl.firstArg (Just @hd.copy)
         lhs.secondArg   = if @hasContexts @tl.secondArg @tl.firstArg

         lhs.firstArgGraph  = if @hasContexts @tl.firstArgGraph @hd.graph
         lhs.secondArgGraph = if @hasContexts @tl.secondArgGraph @tl.firstArgGraph

         tl.graph  = if @hasContexts @lhs.graph @hd.graph
         lhs.graph = @tl.graph

         lhs.firstArgMEntryId   = if @hasContexts @tl.firstArgMEntryId @hd.mEntryId
         lhs.secondArgMEntryId  = if @hasContexts @tl.secondArgMEntryId @tl.firstArgMEntryId
         lhs.firstArgMExitId    = if @hasContexts @tl.firstArgMExitId @hd.mExitId
         lhs.secondArgMExitId   = if @hasContexts @tl.secondArgMExitId @tl.secondArgMExitId
         lhs.firstArgHasRecs    = if @hasContexts @tl.firstArgHasRecs @hd.hasRecs
         lhs.secondArgHasRecs   = if @hasContexts @tl.secondArgHasRecs @tl.firstArgHasRecs
         lhs.firstArgRecNode    = if @hasContexts @tl.firstArgRecNode @hd.recNode
         lhs.secondArgRecNode   = if @hasContexts @tl.secondArgRecNode @tl.secondArgRecNode

         tl.numContexts  = @lhs.numContexts - 1

  | Nil  lhs.firstArg  = Nothing
         lhs.secondArg = Nothing

         lhs.firstArgIdent    = abort "firstArgIdent: no args"
         lhs.secondArgIdent   = abort "secondArgIdent: no args"

         lhs.firstArgGraph  = abort "firstArgGraph: no args"
         lhs.secondArgGraph = abort "secondArgGraph: no args"

         lhs.graph = @lhs.graph

sem Ident
  | Ident
      lhs.isCurrTask = @id_name == @lhs.currTaskName
      lhs.ident      = @id_name

sem SymbIdent
  | SymbIdent
      lhs.ident            = trace_n "SymbIdent.ident" $           @symb_ident.ident
      lhs.isCurrTask       = trace_n "SymbIdent.isCurrTask" $      @symb_ident.isCurrTask

attr GFunDef
  syn funArgs :: {[FreeVar]}

sem GFunDef
  | GFunDef
      lhs.funArgs  = @gfd_args.copy
      lhs.funRhs   = @gfd_rhs.copy

      lhs.mEntryId = @gfd_rhs.mEntryId
      lhs.mExitId  = @gfd_rhs.mExitId

      lhs.graph    = @gfd_rhs.graph

/******************************************************************************/
/* App: common                                                                */
/******************************************************************************/
sem App
  | App
      app_args.numContexts = if @loc.isListApp 0
                             (let funTy  = fromMaybe (abort err) (reifySymbolType @lhs.moduleEnv @app_symb.ident)
                                  err    = "numContexts : failed to find symbol type for " +++ @app_symb.ident
                              in  numContexts funTy)

      lhs.firstArg  = @loc.firstArg
      loc.firstArg  = @app_args.firstArg
      lhs.secondArg = @loc.secondArg
      loc.secondArg = @app_args.firstArg

      lhs.graph = if (trace_n ("App.graph.symb:" +++ @app_symb.ident) $ identIsTask @lhs.moduleEnv @app_symb.ident)
                    @loc.taskGraph
                    @lhs.graph
      lhs.mEntryId = @loc.taskEntryId
      lhs.mExitId  = @loc.taskExitId

      loc.(taskGraph, taskEntryId, taskExitId)
            = case @app_symb.ident of // TODO `parallel`
                // ">>="       -> trace_n "App: >>="       $ (@loc.bindGraph,                    Nothing,                            Nothing)
                "return"    -> trace_n "App: return"    $ (@loc.returnGraph,                  Just @loc.returnId,                 Just @loc.returnId)
                ">>|"       -> trace_n "App: >>|"       $ (@loc.binAppGraph Nothing,          Nothing,                            Nothing)
                "@:"        -> trace_n "App: @:"        $ (@loc.assignGraph,                  Just @loc.assignId,                 Just @loc.assignId)
                ">>*"       -> trace_n "App: >>*"       $ (@loc.stepGraph,                    @loc.stepEntryId,                   @loc.stepExitId)
                "-||-"      -> trace_n "App: -||-"      $ (@loc.parBinAppGraph DisFirstBin,   Nothing,                            Nothing)
                "||-"       -> trace_n "App: ||-"       $ (@loc.parBinAppGraph DisRight,      Nothing,                            Nothing)
                "-||"       -> trace_n "App: -||"       $ (@loc.parBinAppGraph DisLeft,       Nothing,                            Nothing)
                "-&&-"      -> trace_n "App: -&&-"      $ (@loc.parBinAppGraph ConPair,       Nothing,                            Nothing)
                "anyTask"   -> trace_n "App: anyTask"   $ (@loc.parListAppGraph DisFirstList, @loc.parListAppEntryId DisFirstBin, @loc.parListAppExitId DisFirstBin)
                "allTasks"  -> trace_n "App: allTasks"  $ (@loc.parListAppGraph ConAll,       @loc.parListAppEntryId DisFirstBin, @loc.parListAppExitId DisFirstBin)
                _           -> trace_n "App: _"         $ (@loc.taskAppGraph,                 @loc.taskAppId,                     @loc.taskAppId)

      loc.isListApp = @app_symb.ident == "_Cons" || @app_symb.ident == "_Nil"

/******************************************************************************/
/* App: >>=                                                                   */
/******************************************************************************/
sem App
  | App
      loc.bindRhsAppIdent = case @app_args.firstArg of
                              Just (App a)  -> a.app_symb.symb_ident.id_name
                              _             -> abort "Invalid bind"

      loc.bindRhsSymbolType = fromMaybe (abort "mkGraphAlg #2: failed to find symbol type")
                              (reifySymbolType @lhs.moduleEnv @loc.bindRhsAppIdent)
      inst.foobar :: Expression
      inst.foobar = Var { BoundVar | var_ident = {Ident | id_name = "", id_info = abort "This should _not_ be evaluated 1" }
                                   , var_info_ptr = abort "This should _not_ be evaluated 2"
                                   , var_expr_ptr = abort "This should _not_ be evaluated 3" }


      /*inst.bindRhsFunDef :: GFunDef*/
      /*inst.bindRhsFunDef = abort "bindRhsFunDef too early! :(" // fromMaybe (abort "mkGraphAlg #1: failed to find function definition")*/
                            //                           (reifyFunDef @lhs.moduleEnv @loc.bindRhsAppIdent)

      /*bindRhsFunDef.graph = @app_args.firstArgGraph*/

      /*loc.bindGraph = case ( @app_args.firstArgMEntryId, @app_args.firstArgMExitId*/
                           /*, @bindRhsFunDef.mEntryId, @bindRhsFunDef.mExitId) of*/
                        /*(Just _, Just lx, Just rn, Just _)*/
                           /*# patid = withHead freeVarName (abort "Invalid bind")*/
                                   /*$ [x \\ x <- dropContexts @loc.bindRhsSymbolType @bindRhsFunDef.funArgs | x.fv_def_level == -1]*/
                           /*= addEdge (mkEdge patid) (lx, rn) @lhs.graph*/
                        /*(_, lid, rid, _)        = abort "Failed to create bind edge"*/

/******************************************************************************/
/* App: return                                                                */
/******************************************************************************/
sem App
  | App
      loc.(returnId, returnGraph) = undef // TODO No error: eta-reduction
                                    // let node   = GReturn @loc.firstArg
                                    //     // In case of a function application, we want to inspect the type of the
                                    //     // function. If it is a task or a list, treat it differently than any
                                    //     // other type.
                                    //     f _ = GCleanExpression "(return)"
                                    // in  addNode node @lhs.graph

/******************************************************************************/
/* App: >>|                                                                   */
/******************************************************************************/
sem App
  | App
      loc.binAppGraph = \mPat -> undef // case ( @app_args.firstArgMEntryId, @app_args.firstArgMExitId
                                 //      , @app_args.secondArgMEntryId, @app_args.secondArgMExitId) of
                                 //   (Just _, Just lx, Just rn, Just _)  -> addEdge (maybe emptyEdge mkEdge mPat) (lx, rn) @app_args.firstArgGraph
                                 //   _                                   -> abort "binAppGraph"

/******************************************************************************/
/* App: @:                                                                    */
/******************************************************************************/
sem App
  | App
      loc.(assignId, assignGraph) = undef // let (n, g) = addNode (GAssign "Assign node") @lhs.graph
                                    // in  case @app_args.firstArgMEntryId of
                                    //       Just r -> (n, addEmptyEdge (n, r) g)
                                    //       _      -> abort "Illegal task assignment"

/******************************************************************************/
/* App: >>*                                                                   */
/******************************************************************************/
sem App
  | App
      loc.stepGraph   = abort "Step not implemented yet"
      loc.stepEntryId = Nothing
      loc.stepExitId  = Nothing

/******************************************************************************/
/* App: -||-, ||-, -||, -&&-                                                  */
/******************************************************************************/
sem App
  | App
      loc.parBinAppGraph = undef // \join -> let (sid, g1) = addNode GParallelSplit @app_args.graph
                          //              (jid, g2) = addNode (GParallelJoin join) g1
                          //          in  case ( @app_args.firstArgMEntryId, @app_args.firstArgMExitId
                          //                   , @app_args.secondArgMEntryId, @app_args.secondArgMExitId) of
                          //                (_, Just l, Just r, _)
                          //                  # g = addEmptyEdge (sid, l) g2
                          //                  # g = addEmptyEdge (sid, r) g
                          //                  # g = addEmptyEdge (l, jid) g
                          //                  = addEmptyEdge (r, jid) g
                          //                (_, lid, rid, _) = abort "Illegal parBinApp"

/******************************************************************************/
/* App: anyTask, allTasks                                                     */
/******************************************************************************/
sem App
  | App
      loc.parListAppGraph   = \join -> undef
      loc.parListAppEntryId = \join -> undef
      loc.parListAppExitId  = \join -> undef

/******************************************************************************/
/* App: Task application                                                      */
/******************************************************************************/
sem App
  | App
      loc.(taskAppId, taskAppGraph) = if @app_symb.isCurrTask
                                        (Nothing, @lhs.graph)
                                        (let appArgs = map (GCleanExpression o ppCompact) @app_args.ppAgs  // TODO: When do we pprint a Clean expr? And when do we generate a subgraph?
                                             (n, g)  = addNode (GTaskApp @app_symb.ident appArgs) @lhs.graph
                                         in (Just n, g))

sem Expression
  | App
      lhs.graph = @app.graph

  | Let
      lhs.graph = @glet.graph

      inst.glet :: GLet
      inst.glet = mkGLet @lhs.moduleEnv @let_

sem GLet
  | GLet
      lhs.graph = case @loc.mCaseVarExpr of
                    Just e  -> @glet_expr.graph
                    _       -> let (lid, g)  = addNode (GLet @glet_binds.copy) @glet_expr.graph
                                   // TODO: Represent the bindings in any way possible, not just PP
                                   err       = abort "Failed to add let edge; no synthesized ID from let body"
                               in maybe err (\n -> addEmptyEdge (lid, n) g) @loc.connId

      loc.mCaseVarExpr = @glet_binds.mCaseVarExpr

      glet_expr.caseExpr = @loc.mCaseVarExpr

      lhs.recNode = False

      loc.connId = if @glet_expr.recNode (Just @lhs.mergeId) @glet_expr.mEntryId

attr GLetBind GLetBinds
  syn mCaseVarExpr :: {Maybe Expression}

sem GLetBinds
  | Cons  lhs.mCaseVarExpr = @hd.mCaseVarExpr <> @tl.mCaseVarExpr
  | Nil   lhs.mCaseVarExpr = Nothing

sem GLetBind
  | GLetBind lhs.mCaseVarExpr = if (@glb_dst == "_case_var") (Just @glb_src.copy) Nothing

{

(<>) infixr 5 :: (Maybe a) (Maybe a) -> Maybe a
(<>) Nothing  ma  = ma
(<>) ma       _   = ma

mkGinGraph :: Int String GinGraph ModuleEnv Expression -> GinGraph
mkGinGraph mid ctn gg menv expr =
  graph_Syn_Expression (wrap_Expression (sem_Expression expr)
                       (Inh_Expression Nothing ctn gg mid menv))

listExprToList :: Expression -> [Expression]
listExprToList (App app) =
  case app.app_symb.symb_ident.id_name of
    "_Cons" ->
      case app.app_args of
        [head:tail:_] -> [head : listExprToList tail]
        _             -> abort "listExprToList should not happen"
    "_Nil"  -> []
    _       -> abort "listExprToList: App is not a list"
listExprToList _ = []

addEmptyEdge :: (Int, Int) GinGraph -> GinGraph
addEmptyEdge e g = addEdge emptyEdge e g

addNode` :: GNode GinGraph -> SynExpression
addNode` node graph
  # (n, g) = addNode node graph
  = mkSynExpr (Just n) g

// TODO: We need to split this up: one part of this should generate the graph
// for the FunDef and the other part should generate the init and stop nodes.
// Yet another part should just get the right-hand side Expression of a FunDef
// so we can just cata it.
funToGraph :: FunDef {#FunDef} IclModule {#DclModule} -> Optional GGraph
funToGraph {fun_ident=fun_ident, fun_body = TransformedBody tb} fun_defs icl_module dcl_modules
  = Yes $ GGraph mkBody
  where
  mkBody
    # (mergeId, g)  = addNode GMerge emptyGraph
    # inh           = mkInhExpr (mkModuleEnv fun_defs icl_module dcl_modules) g mergeId fun_ident.id_name Nothing
    # gram          = wrapExpr tb.tb_rhs inh
    # g             = graph_Syn_Expression gram
    # (initId, g)   = addNode GInit g
    # g             = if (hasRecs_Syn_Expression gram)
                        (mkRec (mEntryId_Syn_Expression gram) initId mergeId g)
                        (mkNonrec (mEntryId_Syn_Expression gram) initId mergeId g)
    = addStopEdges g

  addStopEdges g
    # leafs        = leafNodes g
    # (stopId, g)  = addNode GStop g
    = foldr (\nid g_ -> addEmptyEdge (nid, stopId) g_) g leafs

  mkRec mfirstId initId mergeId g
    # g = addEmptyEdge (initId, mergeId) g
    = maybe g (\firstId -> addEmptyEdge (mergeId, firstId) g) mfirstId

  mkNonrec mfirstId initId mergeId g
    # g = removeNode mergeId g
    = maybe g (\firstId -> addEmptyEdge (initId, firstId) g) mfirstId

  mkInhExpr menv g mid nm ce = Inh_Expression ce nm g mid menv

  wrapExpr expr inh = wrap_Expression (sem_Expression expr) inh

funToGraph _ _ _ _ = No

instance toString GNode where
  toString GInit = "GInit"
  toString GStop = "GStop"
  toString (GDecision _ _) = "GDecision"
  toString GMerge = "GMerge"
  toString (GLet _) = "GLet"
  toString GParallelSplit = "GParallelSplit"
  toString (GParallelJoin _) = "GParallelJoin"
  toString (GTaskApp _ _) = "GTaskApp"
  toString (GReturn _) = "GReturn"
  toString (GAssign _) = "GAssign"
  toString GStep = "GStep"
  toString GListComprehension = "GListComprehension"

instance Functor Optional where
  fmap _ No      = No
  fmap f (Yes x) = Yes $ f x
/*
Task assignment drawing: Needs a stick.png with a stick figure (can be PDF?)
digraph G {
   rankdir=LR;

    subgraph clusterUser {label="User"; labelloc="b"; peripheries=0; user};
    user [shapefile="stick.png", peripheries=0, style=invis];

    login [label="Log In", shape=ellipse];

    user->login [arrowhead=none];
}
*/
}
