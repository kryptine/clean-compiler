imports
{
from StdClass import class + (..)
from StdOverloaded import class < (..)
from StdInt import instance + Int, instance < Int
from StdList import ++, foldr, map
from StdOverloaded import class +++ (..)
from StdString import instance +++ {#Char}, instance toString Int, instance == {#Char}
from StdFunc import o
from StdBool import ||
import StdMisc
import Data.Void
import Data.Func
import Data.List

import Data.Graph
import Data.Maybe
import Text.PPrint
import Tonic.AbsSyn
import Tonic.Util
from syntax import :: Optional (..), :: FunDef {..}, :: FunInfo, :: FunKind,
  :: FunctionBody {..}, :: TransformedBody {..}, :: CheckedBody, :: ParsedBody
}

attr Expression Expressions Ident BoundVar FreeVar FreeVars SymbIdent
  BasicValue DefinedSymbol Selection Selections GExpression GLet GLetBind
  GLetBinds GlobalDefinedSymbol App SymbolType GFunDef
  inh mergeId                            :: {Int}
  inh currTaskName                       :: {String}
  inh caseExpr                           :: {Maybe Expression}
  chn graph                              :: {GinGraph}
  syn hasRecs       use {||}  {False}    :: {Bool}
  syn recNode       use {||}  {False}    :: {Bool}
  syn mEntryId      use {<>}  {Nothing}  :: {Maybe Int}
  syn mExitId       use {<>}  {Nothing}  :: {Maybe Int}

attr App SymbIdent
  syn mFunDef     :: {Maybe GFunDef}
  syn mSymbolType :: {Maybe SymbolType}

attr SymbIdent
  syn isCurrTask :: {Bool}

attr SymbIdent Ident
  syn ident :: {String}

sem Ident
  | Ident lhs.ident = @id_name

sem App
  | App lhs.mFunDef = @app_symb.mFunDef
        lhs.mSymbolType = @app_symb.mSymbolType

sem SymbIdent
  | SymbIdent
     lhs.mFunDef      = reifyFunDef @lhs.moduleEnv @symb_ident.copy
     lhs.mSymbolType  = reifySymbolType @lhs.moduleEnv @symb_ident.copy

     loc.ident        = @symb_ident.ident
     lhs.ident        = @loc.ident
     lhs.isCurrTask   = @loc.ident == @lhs.currTaskName

attr GFunDef
  syn funArgs :: {[FreeVar]}
  syn funRhs  :: Expression

sem GFunDef
  | GFunDef
      lhs.funArgs = @gfd_args.copy
      lhs.funRhs  = @gfd_rhs.copy

      lhs.mEntryId = @gfd_rhs.mEntryId
      lhs.mExitId  = @gfd_rhs.mExitId

sem App
  | App
      lhs.graph = if (symbIdentIsTask @lhs.moduleEnv @app_symb.copy)
                    @loc.taskGraph
                    @lhs.graph
      lhs.mEntryId = @loc.taskEntryId
      lhs.mExitId  = @loc.taskExitId

      loc.(taskGraph, taskEntryId, taskExitId) = case @app_symb.ident of // TODO `parallel`
                                                   ">>="       -> (@loc.bindGraph, Nothing, Nothing)
                                                   "return"    -> (@loc.returnGraph, Just @loc.returnId, Just @loc.returnId)
                                                   ">>|"       -> (@loc.binAppGraph Nothing, @loc.binAppEntryId Nothing, @loc.binAppExitId Nothing)
                                                   "@:"        -> (@loc.assignGraph, @loc.assignEntryId, @loc.assignExitId)
                                                   ">>*"       -> (@loc.stepGraph, @loc.stepEntryId, @loc.stepExitId)
                                                   "-||-"      -> (@loc.parBinAppGraph DisFirstBin, @loc.parBinAppEntryId DisFirstBin, @loc.parBinAppExitId DisFirstBin)
                                                   "||-"       -> (@loc.parBinAppGraph DisRight, @loc.parBinAppEntryId DisFirstBin, @loc.parBinAppExitId DisFirstBin)
                                                   "-||"       -> (@loc.parBinAppGraph DisLeft, @loc.parBinAppEntryId DisFirstBin, @loc.parBinAppExitId DisFirstBin)
                                                   "-&&-"      -> (@loc.parBinAppGraph ConPair, @loc.parBinAppEntryId DisFirstBin, @loc.parBinAppExitId DisFirstBin)
                                                   "anyTask"   -> (@loc.parListAppGraph DisFirstList, @loc.parListAppEntryId DisFirstBin, @loc.parListAppExitId DisFirstBin)
                                                   "allTasks"  -> (@loc.parListAppGraph ConAll, @loc.parListAppEntryId DisFirstBin, @loc.parListAppExitId DisFirstBin)
                                                   _           -> (@loc.taskAppGraph, @loc.taskAppId, @loc.taskAppId)

      loc.nodictargs = dropAppContexts @copy @lhs.moduleEnv

      loc.(bindLhsExpr, bindRhsApp) =  case @loc.nodictargs of
                                         [e:App a:_] -> (e, a)
                                         // TODO: Do not throw an error: bind can be eta-reduced
                                         _                 -> abort ("Invalid bind: ") // +++ (intercalateString " " $ map (\x -> "'" +++ mkPretty @lhs.moduleEnv x +++ "'") @loc.nodictargs))

      inst.bindLhsExprI :: Expression
      inst.bindLhsExprI = @loc.bindLhsExpr

      inst.bindRhsAppI :: App
      inst.bindRhsAppI = @loc.bindRhsApp

      loc.bindRhsSymbolType = fromMaybe (abort "mkGraphAlg #2: failed to find symbol type")
                              @bindRhsAppI.mSymbolType

      inst.bindRhsFunDef :: GFunDef
      inst.bindRhsFunDef = fromMaybe (abort "mkGraphAlg #1: failed to find function definition")
                           @bindRhsAppI.mFunDef

      inst.bindRhsSymbolTypeI :: SymbolType
      inst.bindRhsSymbolTypeI = @loc.bindRhsSymbolType

      loc.bindGraph = case ( @bindLhsExprI.mEntryId, @bindLhsExprI.mExitId
                           , @bindRhsFunDef.mEntryId, @bindRhsFunDef.mExitId) of
                        (Just _, Just lx, Just rn, Just _)
                           # patid = withHead freeVarName (abort "Invalid bind")
                                   $ [x \\ x <- dropContexts @loc.bindRhsSymbolType @bindRhsFunDef.funArgs | x.fv_def_level == -1]
                           = addEdge (mkEdge patid) (lx, rn) @lhs.graph
                        (_, lid, rid, _)        = edgeErr @lhs.moduleEnv "bind edge" lid @loc.bindLhsExpr rid @bindRhsFunDef.funRhs

      loc.(returnId, returnGraph) = // TODO No error: eta-reduction
                                    let node   = GReturn $ withHead f (abort "Invalid return") @loc.nodictargs
                                        // In case of a function application, we want to inspect the type of the
                                        // function. If it is a task or a list, treat it differently than any
                                        // other type.
                                        f _ = GCleanExpression "(return)"
                                    in  addNode node @lhs.graph

      loc.binAppGraph = \mPat -> undef
      loc.binAppEntryId = \mPat -> undef
      loc.binAppExitId = \mPat -> undef

      loc.assignGraph = undef
      loc.assignEntryId = undef
      loc.assignExitId = undef

      loc.stepGraph = abort "Step not implemented yet"
      loc.stepEntryId = undef
      loc.stepExitId = undef

      loc.parBinAppGraph   = \join -> undef
      loc.parBinAppEntryId = \join -> undef
      loc.parBinAppExitId  = \join -> undef

      loc.parListAppGraph   = \join -> undef
      loc.parListAppEntryId = \join -> undef
      loc.parListAppExitId  = \join -> undef

      loc.(taskAppId, taskAppGraph) = if @app_symb.isCurrTask
                                        (Nothing, @lhs.graph)
                                        (let appArgs = map (GCleanExpression o ppCompact) @app_args.ppAgs  // TODO: When do we pprint a Clean expr? And when do we generate a subgraph?
                                             (n, g)  = addNode (GTaskApp @app_symb.ident appArgs) @lhs.graph
                                         in (Just n, g))

sem Expression
  | App
      lhs.graph = @app.graph

  | Let
      lhs.graph = @glet.graph

      inst.glet :: GLet
      inst.glet = mkGLet @lhs.moduleEnv @let_

sem GLet
  | GLet
      lhs.graph = case @loc.mCaseVarExpr of
                    Just e  -> @glet_expr.graph
                    _       -> let (lid, g)  = addNode (GLet @glet_binds.copy) @glet_expr.graph
                                   // TODO: Represent the bindings in any way possible, not just PP
                                   err       = abort "Failed to add let edge; no synthesized ID from let body"
                               in maybe err (\n -> addEmptyEdge (lid, n) g) @loc.connId

      loc.mCaseVarExpr = @glet_binds.mCaseVarExpr

      glet_expr.caseExpr = @loc.mCaseVarExpr

      lhs.recNode = False

      loc.connId = if @glet_expr.recNode (Just @lhs.mergeId) @glet_expr.mEntryId

attr GLetBind GLetBinds
  syn mCaseVarExpr :: {Maybe Expression}

sem GLetBinds
  | Cons  lhs.mCaseVarExpr = @hd.mCaseVarExpr <> @tl.mCaseVarExpr
  | Nil   lhs.mCaseVarExpr = Nothing

sem GLetBind
  | GLetBind lhs.mCaseVarExpr = if (@glb_dst == "_case_var") (Just @glb_src.copy) Nothing

{

(<>) infixr 5 :: (Maybe a) (Maybe a) -> Maybe a
(<>) Nothing  ma  = ma
(<>) ma       _   = ma

mkGinGraph :: Int String GinGraph ModuleEnv Expression -> GinGraph
mkGinGraph mid ctn gg menv expr =
  graph_Syn_Expression (wrap_Expression (sem_Expression expr)
                       (Inh_Expression Nothing ctn gg mid menv))

listExprToList :: Expression -> [Expression]
listExprToList (App app) =
  case app.app_symb.symb_ident.id_name of
    "_Cons" ->
      case app.app_args of
        [head:tail:_] -> [head : listExprToList tail]
        _             -> abort "listExprToList should not happen"
    "_Nil"  -> []
    _       -> abort "listExprToList: App is not a list"
listExprToList _ = []

nodeErr :: ModuleEnv (Maybe Int) Expression -> String
nodeErr menv mn expr = ppCompact (ppExpression menv expr) +++ "\n" +++
  maybe "for which its ID is unknown" (\n -> "with node ID " +++ toString n) mn

edgeErr :: ModuleEnv String (Maybe Int) Expression (Maybe Int) Expression -> a
edgeErr menv errmsg lid lexpr rid rexpr = abort ("Cannot create " +++ errmsg
  +++ " between left expression\n\t" +++ nodeErr menv lid lexpr
  +++ " and right expression\n\t" +++ nodeErr menv rid rexpr +++ "\n")

addEmptyEdge :: (Int, Int) GinGraph -> GinGraph
addEmptyEdge e g = addEdge emptyEdge e g

addNode` :: GNode GinGraph -> SynExpression
addNode` node graph
  # (n, g) = addNode node graph
  = mkSynExpr (Just n) g

// TODO: We need to split this up: one part of this should generate the graph
// for the FunDef and the other part should generate the init and stop nodes.
// Yet another part should just get the right-hand side Expression of a FunDef
// so we can just cata it.
funToGraph :: FunDef {#FunDef} IclModule {#DclModule} -> Optional GGraph
funToGraph {fun_ident=fun_ident, fun_body = TransformedBody tb} fun_defs icl_module dcl_modules
  = Yes $ GGraph mkBody
  where
  mkBody
    # (mergeId, g)  = addNode GMerge emptyGraph
    # inh           = mkInhExpr (mkModuleEnv fun_defs icl_module dcl_modules) g mergeId fun_ident.id_name Nothing
    # gram          = wrapExpr tb.tb_rhs inh
    # g             = graph_Syn_Expression gram
    # (initId, g)   = addNode GInit g
    # g             = if (hasRecs_Syn_Expression gram)
                        (mkRec (mEntryId_Syn_Expression gram) initId mergeId g)
                        (mkNonrec (mEntryId_Syn_Expression gram) initId mergeId g)
    = addStopEdges g

  addStopEdges g
    # leafs        = leafNodes g
    # (stopId, g)  = addNode GStop g
    = foldr (\nid g_ -> addEmptyEdge (nid, stopId) g_) g leafs

  mkRec mfirstId initId mergeId g
    # g = addEmptyEdge (initId, mergeId) g
    = maybe g (\firstId -> addEmptyEdge (mergeId, firstId) g) mfirstId

  mkNonrec mfirstId initId mergeId g
    # g = removeNode mergeId g
    = maybe g (\firstId -> addEmptyEdge (initId, firstId) g) mfirstId

  mkInhExpr menv g mid nm ce = Inh_Expression ce nm g mid menv

  wrapExpr expr inh = wrap_Expression (sem_Expression expr) inh

funToGraph _ _ _ _ = No

instance toString GNode where
  toString GInit = "GInit"
  toString GStop = "GStop"
  toString (GDecision _ _) = "GDecision"
  toString GMerge = "GMerge"
  toString (GLet _) = "GLet"
  toString GParallelSplit = "GParallelSplit"
  toString (GParallelJoin _) = "GParallelJoin"
  toString (GTaskApp _ _) = "GTaskApp"
  toString (GReturn _) = "GReturn"
  toString (GAssign _) = "GAssign"
  toString GStep = "GStep"
  toString GListComprehension = "GListComprehension"

/*
Task assignment drawing: Needs a stick.png with a stick figure (can be PDF?)
digraph G {
   rankdir=LR;

    subgraph clusterUser {label="User"; labelloc="b"; peripheries=0; user};
    user [shapefile="stick.png", peripheries=0, style=invis];

    login [label="Log In", shape=ellipse];

    user->login [arrowhead=none];
}
*/
}
